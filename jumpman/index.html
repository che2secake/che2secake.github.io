<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ジャンプマンゲーム</title>
<style>
  :root{
    --bg:#f6f7fb; --panel:#ffffff; --text:#111827; --muted:#4b5563;
    --fg:#000000;            /* ★ 人（黒） */
    --block:#000000;         /* ★ ブロック（黒） */
    --ground:#e5e7eb; --border:#e5e7eb;
    --shadow:0 8px 24px rgba(0,0,0,.08);
    --accent:#ef4444;        /* JUMPボタンの赤 */
  }
  *{box-sizing:border-box}
  html,body{
    height:100%;margin:0;background:var(--bg);color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP","Hiragino Sans","Yu Gothic UI",sans-serif;
    overflow:hidden
  }
  header{
    padding:12px 16px;border-bottom:1px solid var(--border);background:var(--panel);
    display:flex;align-items:center;justify-content:space-between;gap:12px;box-shadow:var(--shadow)
  }
  h1{margin:0;font-size:18px;white-space:nowrap}
  .score{
    font-weight:800;background:#f3f4f6;border:1px solid var(--border);
    color:#111827;padding:6px 10px;border-radius:999px;font-variant-numeric:tabular-nums
  }
  main{height:calc(100dvh - 56px);max-width:980px;margin:0 auto;padding:12px;display:flex;flex-direction:column}
  .stage{
    position:relative;flex:1;border:1px solid var(--border);border-radius:12px;overflow:hidden;
    background:linear-gradient(180deg,#ffffff,#f6f7fb);box-shadow:var(--shadow)
  }
  canvas{width:100%;height:100%;display:block;touch-action:none}

  /* ★ 中央のSTART/RESTARTは無装飾（半透明背景やカードを撤去） */
  .overlay{
    position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
    background:transparent; /* 装飾なし */
    gap:12px;flex-direction:column; pointer-events:none;
  }
  .overlay .plain{
    pointer-events:auto; background:transparent; border:1px solid #111; color:#111;
    padding:10px 18px; font-weight:800; border-radius:8px; cursor:pointer;
  }
  .overlay.hidden{ display:none; }

  /* 画面下のスマホ用JUMPボタン（そのまま） */
  .jumpbar{
    position:absolute;left:0;right:0;bottom:10px;display:flex;justify-content:center;pointer-events:none;
  }
  .jumpbtn{
    pointer-events:auto;
    min-width:200px; width:60%; max-width:520px;
    padding:16px 20px;border-radius:14px;
    appearance:none;border:2px solid #dc2626;background:var(--accent);color:#fff;
    font-size:20px;font-weight:900;letter-spacing:.03em;
    box-shadow:0 8px 16px rgba(239,68,68,.25);
    touch-action:manipulation;
  }
  .jumpbtn:active{ transform:translateY(1px); filter:brightness(.95); }
  @media (min-width:980px){ .jumpbtn{ width:40%; } }
</style>
</head>
<body>
  <header>
    <h1>ジャンプマンゲーム</h1>
    <!-- ★ スコア＝生存時間（秒・小数1桁） -->
    <div class="score">TIME: <span id="score">0.0</span>s</div>
  </header>

  <main>
    <div class="stage" id="stage">
      <canvas id="game" width="720" height="1080" aria-label="ゲーム画面"></canvas>

      <!-- ★ 無装飾のSTART/RESTART（機能のみ残す） -->
      <div id="overlay" class="overlay" role="dialog" aria-modal="true">
        <button id="btnStart" class="plain" type="button" aria-label="開始">START</button>
      </div>

      <!-- 画面下のJUMPボタン -->
      <div class="jumpbar">
        <button id="jumpBtn" class="jumpbtn" type="button" aria-label="ジャンプ">JUMP!</button>
      </div>
    </div>
  </main>

<script>
/* ================== スタート／リスタート管理 ================== */
let state = 'idle';          // 'idle' | 'playing' | 'gameover'
let starting = false;        // 多重開始防止
let lastT = 0;               // ループ用
let playStartAt = 0;         // ★ 開始時刻（ms）

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const stage = document.getElementById('stage');
const scoreEl = document.getElementById('score');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('btnStart');
const jumpBtn  = document.getElementById('jumpBtn');

function fitCanvas(){
  const rect = stage.getBoundingClientRect();
  canvas.width  = Math.max(320, Math.floor(rect.width));
  canvas.height = Math.max(420, Math.floor(rect.height));
  onResize();
}
addEventListener('resize', fitCanvas, {passive:true});

function toPlaying(){
  state = 'playing';
  overlay.classList.add('hidden');
  keyJump = false; jumpPressed = false; jumpHeldMs = 0;
  // ★ 計測開始
  playStartAt = performance.now();
}
function toGameOver(){
  state = 'gameover';
  overlay.classList.remove('hidden');
  startBtn.textContent = 'RESTART';
}
function fullReset(){
  state = 'idle'; starting = false; lastT = 0;
  keyJump = false; jumpPressed = false; jumpHeldMs = 0;
  fitCanvas();
  initGameObjects();
  updateHUD(0);
  startBtn.textContent = 'START';
  overlay.classList.remove('hidden');
}
function safeStart(){
  if(starting || state==='playing') return;
  starting = true;
  fullReset();
  toPlaying();
  setTimeout(()=>{ starting=false; }, 120);
}
function onBtn(e){ e?.preventDefault?.(); e?.stopPropagation?.(); safeStart(); }
startBtn.addEventListener('click', onBtn);
startBtn.addEventListener('pointerdown', onBtn);
startBtn.addEventListener('touchstart', onBtn, {passive:false});

/* ================== ゲーム固有ロジック（ジャンプマン） ================== */
const CFG = {
  groundHRatio: 0.16,
  grav: 2100,
  jumpBoostAcc: 4200,   // ★ 少し弱めにしてスマホで飛び過ぎない
  maxHoldMs: 180,       // ★ 長押しの上限も短縮
  jumpCooldownMs: 90,
  maxJumps: 3,
  initialVyGround: -600,  // ★ 初速も控えめに
  initialVyAir:   -540,

  player: { w: 44, h: 72 },

  block:  { w: 44, h: 64, speed: 500, heightMaxScale: 3.0 },
  spawnGapMin: 460,
  spawnGapMax: 1500,
  spawnSpeedupPer100Score: 0.10
};

let groundY = 0;
let player;
let blocks = [];
let spawnTimer = 0, nextSpawn = 0;

// 3段ジャンプ＋可変ジャンプ
let jumpsLeft = CFG.maxJumps;
let keyJump = false, jumpPressed = false, jumpHeldMs = 0, lastJumpReleaseAt = 0;

// ★ 画面外に出ないための天井（上限）を導入
let ceilingY = 0;  // プレイヤーの頭頂がこの高さより上に行かない

function initGameObjects(){
  groundY = Math.floor(canvas.height * (1 - CFG.groundHRatio));
  ceilingY = Math.max(40, Math.floor(canvas.height * 0.18)); // 画面上18%付近を天井に
  player = {
    x: Math.floor(canvas.width * 0.18),
    y: groundY - CFG.player.h,
    vx: 0, vy: 0,
    w: CFG.player.w, h: CFG.player.h,
    onGround: true
  };
  jumpsLeft = CFG.maxJumps;
  blocks.length = 0;
  spawnTimer = 0;
  nextSpawn = pickNextSpawn();
}

function onResize(){
  groundY = Math.floor(canvas.height * (1 - CFG.groundHRatio));
  ceilingY = Math.max(40, Math.floor(canvas.height * 0.18));
  if (player) {
    const bottom = player.y + player.h;
    const diff = groundY - bottom;
    player.y += diff;
    if (player.y + player.h >= groundY) {
      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
      jumpsLeft = CFG.maxJumps;
    }
  }
}

/* ====== スポーン間隔 ====== */
function pickNextSpawn(){
  // スコアは時間ベースに変更したので、短縮は「経過時間」で掛かる
  const elapsed = Math.max(0, (performance.now() - playStartAt) / 1000);
  const factor = Math.max(0.55, 1 - (elapsed/100)*CFG.spawnSpeedupPer100Score);
  const min = CFG.spawnGapMin * factor;
  const max = CFG.spawnGapMax * factor;
  return min + Math.random() * (max - min);
}

/* ====== 入力（キー） ====== */
addEventListener('keydown', e=>{
  if(state!=='playing'){ if(e.key===' '||e.key==='ArrowUp') safeStart(); return; }
  if(e.key===' ' || e.key==='ArrowUp'){
    if(!keyJump){ keyJump = true; jumpPressed = true; }
  }
});
addEventListener('keyup', e=>{
  if(e.key===' ' || e.key==='ArrowUp'){
    keyJump = false; jumpPressed = false; jumpHeldMs = 0;
    lastJumpReleaseAt = performance.now();
  }
});

/* ====== 入力（キャンバスのタップでもジャンプ可） ====== */
canvas.addEventListener('pointerdown', e=>{
  if(state!=='playing'){ safeStart(); return; }
  if(!keyJump){ keyJump = true; jumpPressed = true; }
});
canvas.addEventListener('pointerup', e=>{
  keyJump = false; jumpPressed = false; jumpHeldMs = 0;
  lastJumpReleaseAt = performance.now();
});
canvas.addEventListener('pointercancel', e=>{
  keyJump = false; jumpPressed = false; jumpHeldMs = 0;
  lastJumpReleaseAt = performance.now();
});

/* ====== 入力（JUMPボタン） ====== */
function jumpPressStart(e){
  e?.preventDefault?.(); e?.stopPropagation?.();
  if(state!=='playing'){ safeStart(); return; }
  if(!keyJump){ keyJump = true; jumpPressed = true; }
}
function jumpPressEnd(e){
  e?.preventDefault?.(); e?.stopPropagation?.();
  keyJump = false; jumpPressed = false; jumpHeldMs = 0;
  lastJumpReleaseAt = performance.now();
}
jumpBtn.addEventListener('pointerdown', jumpPressStart);
jumpBtn.addEventListener('pointerup',   jumpPressEnd);
jumpBtn.addEventListener('pointercancel', jumpPressEnd);
jumpBtn.addEventListener('touchstart', jumpPressStart, {passive:false});
jumpBtn.addEventListener('touchend',   jumpPressEnd);
jumpBtn.addEventListener('mousedown',  jumpPressStart);
jumpBtn.addEventListener('mouseup',    jumpPressEnd);
jumpBtn.addEventListener('mouseleave', jumpPressEnd);

/* ====== 更新 ====== */
function update(dt){
  // ★ スコア＝生存時間（s）。プレイ中のみ更新
  const elapsed = Math.max(0, (performance.now() - playStartAt) / 1000);
  updateHUD(elapsed);

  // スポーン（距離ランダム）
  spawnTimer += dt*1000;
  if(spawnTimer >= nextSpawn){
    spawnTimer = 0;
    spawnBlock();
    nextSpawn = pickNextSpawn();
  }

  // 3段ジャンプ開始判定
  const now = performance.now();
  if (jumpPressed && jumpsLeft > 0 && (now - lastJumpReleaseAt) > CFG.jumpCooldownMs){
    const initVy = (player.onGround ? CFG.initialVyGround : CFG.initialVyAir);
    player.onGround = false;
    player.vy = initVy;
    jumpPressed = false;
    jumpHeldMs = 0;
    jumpsLeft--;
  }

  // 長押しで対空（各ジャンプ上限あり）
  if (keyJump && !player.onGround && jumpHeldMs < CFG.maxHoldMs){
    player.vy -= CFG.jumpBoostAcc * dt;
    jumpHeldMs += dt*1000;
  }

  // 物理
  player.vy += CFG.grav * dt;
  player.y  += player.vy * dt;

  // ★ 天井（画面上部）でクランプ：上に抜けない
  const headY = player.y; // 頭のY（yが小さいほど上）
  if(headY <= ceilingY){
    player.y = ceilingY;
    if(player.vy < 0) player.vy = 0; // これ以上上がらない
  }

  // 地面で着地（回復）
  if(player.y + player.h >= groundY){
    player.y = groundY - player.h;
    player.vy = 0;
    if(!player.onGround){
      player.onGround = true;
      jumpsLeft = CFG.maxJumps;
      jumpHeldMs = 0;
    }
  }

  // ブロック
  for(let i=blocks.length-1;i>=0;i--){
    const b = blocks[i];
    b.x -= b.speed * dt;
    if(b.x + b.w < -10) blocks.splice(i,1);
  }

  // 衝突
  for(const b of blocks){
    if(rectHit(player, b)){ toGameOver(); return; }
  }
}

/* ====== ブロック生成（高さ最大3倍） ====== */
function spawnBlock(){
  const maxH = Math.min(CFG.block.h * CFG.block.heightMaxScale, groundY - ceilingY - 20);
  const h = Math.max(24, Math.round( lerp(CFG.block.h, maxH, Math.random()) ));
  const w = Math.round( CFG.block.w * (0.9 + Math.random()*0.4) );
  const y = groundY - h;
  // 経過時間で少し速く
  const elapsed = Math.max(0, (performance.now() - playStartAt) / 1000);
  const speed = CFG.block.speed * (1.0 + Math.min(0.6, elapsed/60/5)); // 5分で+60%まで
  blocks.push({ x: canvas.width + 20, y, w, h, speed });
}

function lerp(a,b,t){ return a + (b-a)*t; }
function rectHit(a,b){
  return !(a.x+a.w < b.x || b.x+b.w < a.x || a.y+a.h < b.y || b.y+b.h < a.y);
}

/* ====== 描画（黒シルエット） ====== */
function render(ctx){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // 地面
  ctx.fillStyle = 'var(--ground)';
  ctx.fillRect(0, groundY, canvas.width, canvas.height-groundY);

  // ブロック（黒）
  for(const b of blocks){
    ctx.fillStyle = 'var(--block)';
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  // ジャンプマン（黒のスティックマン）
  drawMan(player);
}

function drawMan(p){
  const x = p.x + p.w/2;
  const y = p.y + p.h;

  ctx.strokeStyle = 'var(--fg)';
  ctx.lineWidth = 5;
  ctx.lineCap = 'round';

  // 頭
  ctx.beginPath(); ctx.arc(x, y - 0.86*p.h, 10, 0, Math.PI*2); ctx.stroke();

  // 胴
  ctx.beginPath(); ctx.moveTo(x, y-0.8*p.h); ctx.lineTo(x, y-0.45*p.h); ctx.stroke();

  // 腕（軽くスイング）
  const t = performance.now() * 0.01;
  const swing = Math.sin(t) * 8;
  ctx.beginPath(); ctx.moveTo(x, y-0.7*p.h); ctx.lineTo(x - 20 + swing, y-0.55*p.h); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y-0.7*p.h); ctx.lineTo(x + 20 - swing, y-0.55*p.h); ctx.stroke();

  // 脚
  const onG = p.onGround;
  const phase = Math.cos(t*0.6);
  const k = onG ? 1 : 0.3;
  ctx.beginPath(); ctx.moveTo(x, y-0.45*p.h); ctx.lineTo(x - 16, y - 0.06*p.h - 8*k*phase); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(x, y-0.45*p.h); ctx.lineTo(x + 16, y - 0.06*p.h + 8*k*phase); ctx.stroke();
}

/* ====== HUD（時間表示・小数1桁） ====== */
function updateHUD(seconds){
  const s = Math.max(0, seconds||0);
  scoreEl.textContent = (Math.floor(s*10)/10).toFixed(1);
}

/* ====== ループ ====== */
function loop(t){
  const dt = Math.min(32, t - lastT) / 1000 || 0;
  lastT = t;

  if(state === 'playing'){ update(dt); }
  render(ctx);

  requestAnimationFrame(loop);
}

/* ====== 起動 ====== */
fullReset();
requestAnimationFrame(loop);
</script>
</body>
</html>
