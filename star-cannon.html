<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>スターキャノン</title>
<style>
  :root{
    --bg:#070b1a; --panel:#0b1220; --text:#e5e7eb; --muted:#9ca3af;
    --skyTop:#0b1023; --skyBottom:#0b1633;
    --star:#fcd34d; --starEdge:#7c5c0a;
    --beam:#60a5fa; --beamCore:#93c5fd;
    --border:rgba(255,255,255,.08);
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP","Hiragino Sans","Yu Gothic UI",sans-serif;
    overflow:hidden; touch-action:none;
  }
  header{
    height:44px; padding:8px 12px; border-bottom:1px solid var(--border); background:var(--panel);
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  h1{margin:0; font-size:16px; white-space:nowrap}
  .score{
    font-weight:800; background:rgba(255,255,255,.06); border:1px solid var(--border);
    padding:4px 10px; border-radius:999px; font-variant-numeric:tabular-nums; font-size:13px;
  }
  main{
    height:calc(100dvh - 44px); max-width:980px; margin:0 auto; padding:8px; display:flex; flex-direction:column;
  }
  .stage{
    position:relative; flex:1; border:1px solid var(--border); border-radius:12px; overflow:hidden;
    background:linear-gradient(180deg,var(--skyTop),var(--skyBottom));
  }
  canvas{width:100%; height:100%; display:block}

  .overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .overlay .plain{
    pointer-events:auto; background:transparent; border:1px solid #fff; color:#fff;
    padding:10px 18px; font-weight:800; border-radius:8px; cursor:pointer; touch-action:manipulation;
  }
  .overlay.hidden{ display:none; }

  .hud{
    position:absolute; left:8px; top:8px; color:var(--muted); font-size:12px; background:rgba(0,0,0,.25);
    padding:3px 6px; border-radius:8px; border:1px solid var(--border)
  }
</style>
</head>
<body>
  <header>
    <h1>スターキャノン</h1>
    <div class="score">SCORE: <span id="score">0</span></div>
  </header>

  <main>
    <section class="stage" id="stage">
      <canvas id="game" width="720" height="1080" aria-label="ゲーム画面"></canvas>

      <div id="hud" class="hud">MISS: <span id="miss">0</span>/3</div>

      <div id="overlay" class="overlay" role="dialog" aria-modal="true">
        <button id="btnStart" class="plain" type="button" aria-label="開始">START</button>
      </div>
    </section>
  </main>

<script>
/* ======= 状態 ======= */
let state='idle', starting=false, lastT=0;

const stage   = document.getElementById('stage');
const canvas  = document.getElementById('game');
const ctx     = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const missEl  = document.getElementById('miss');
const overlay = document.getElementById('overlay');
const startBtn= document.getElementById('btnStart');

let viewW=720, viewH=1080, dpr=1;
function fitCanvas(){
  const rect = stage.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio||1, 2);
  canvas.width  = Math.max(360, Math.floor(rect.width  * dpr));
  canvas.height = Math.max(480, Math.floor(rect.height * dpr));
  canvas.style.width  = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  viewW = rect.width; viewH = rect.height;
  onResize();
}
addEventListener('resize', fitCanvas, {passive:true});

/* ======= スタート/リスタート ======= */
function toPlaying(){
  state='playing';
  overlay.classList.add('hidden');
  score=0; misses=0; elapsed=0; updateHUD();
  stars.length=particles.length=beams.length=0;
  spawnTimer=0; nextSpawn=pickNextSpawn();
  aiming=false; aimDX=0; aimDY=-1; capturedPointer=null; cannonAngle=-Math.PI/2;
  fireTimer=0;
}
function toGameOver(){
  state='gameover';
  overlay.classList.remove('hidden');
  startBtn.textContent='RESTART';
  aiming=false;
}
function fullReset(){
  state='idle'; starting=false; lastT=0;
  fitCanvas();
  initGameObjects();
  startBtn.textContent='START';
  overlay.classList.remove('hidden');
  updateHUD();
}
function safeStart(){
  if(starting || state==='playing') return;
  starting = true;
  fullReset(); toPlaying();
  setTimeout(()=>{ starting=false; }, 120);
}
function onBtn(e){ e?.preventDefault?.(); e?.stopPropagation?.(); safeStart(); }
startBtn.addEventListener('click', onBtn);
startBtn.addEventListener('pointerdown', onBtn);
startBtn.addEventListener('touchstart', onBtn, {passive:false});
canvas.addEventListener('pointerdown', e=>{ if(state!=='playing') onBtn(e); });

/* ======= 設定 ======= */
const CFG = {
  // 星
  starRMin: 10, starRMax: 16,
  rainbowChance: 0.07,
  rainbowBonus: 5,

  // 落下（時間で緩やか加速）
  vyBaseMin: 80, vyBaseMax: 140,
  vyMaxBoost: 2.2,
  driftMax: 40,

  // スポーン（緩やか短縮）
  spawnMin: 380, spawnMax: 1000,
  spawnMinLimit: 240,

  // ルール
  maxMiss: 3,
  scorePerStar: 10,

  // エフェクト
  particleN: 16,

  // 照準
  aimRadius: 110,

  // ★ パルスビーム（短い弾を断続発射）
  beamLen: 80,          // 見た目の長さ（px）
  beamSpeed: 900,       // 進む速さ（px/s）
  fireInterval: 0.12,   // 発射間隔（秒）→ 撃ちすぎ防止
};

/* なめらか加速 */
function smooth01(x, k=35){ return 1 - Math.exp(-x / k); }
function speedScaleByTime(sec){
  const t = smooth01(sec, 60);
  return 1 + CFG.vyMaxBoost * t;
}
function spawnMillisByScore(score){
  const t = smooth01(score, 50);
  const min = Math.max(CFG.spawnMinLimit, CFG.spawnMin - 240*t);
  const max = CFG.spawnMax - 260*t*0.7;
  return {min, max:Math.max(min+80, max)};
}

/* ======= 変数 ======= */
let score=0, misses=0, elapsed=0;
let stars=[], particles=[];
let spawnTimer=0, nextSpawn=600;

/* 砲台照準（方向ベクトル） */
let aiming=false;
let aimDX=0, aimDY=-1;
let capturedPointer=null;
let cannonAngle=-Math.PI/2;

/* パルスビーム */
let beams=[];          // {x,y,dx,dy,len}
let fireTimer=0;

/* ======= 初期化 ======= */
function initGameObjects(){
  score=0; misses=0; elapsed=0;
  stars.length=particles.length=beams.length=0;
  spawnTimer=0; nextSpawn=pickNextSpawn();
  aiming=false; aimDX=0; aimDY=-1; cannonAngle=-Math.PI/2;
  fireTimer=0;
}
function onResize(){}

/* ======= 便利 ======= */
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function pickNextSpawn(){
  const {min,max} = spawnMillisByScore(score);
  return min + Math.random()*(max-min);
}

/* ======= 星生成 ======= */
function spawnStar(){
  const isRainbow = Math.random() < CFG.rainbowChance;
  const r  = isRainbow ? rand(CFG.starRMin+2, CFG.starRMax+3) : rand(CFG.starRMin, CFG.starRMax);
  const x  = rand(r+8, viewW - (r+8));
  const vy = rand(CFG.vyBaseMin, CFG.vyBaseMax) * speedScaleByTime(elapsed);
  const vx = rand(-CFG.driftMax, CFG.driftMax);
  stars.push({x, y:-r-10, r, vx, vy, type: isRainbow?'rainbow':'normal'});
}

/* ======= 入力：砲台近傍で角度指定 ======= */
function canvasPos(e){
  const rect = canvas.getBoundingClientRect();
  return {x:(e.clientX-rect.left), y:(e.clientY-rect.top)};
}
function cannonPos(){ return {x:viewW/2, y:viewH-24}; }
function updateAimFromPoint(px,py){
  const {x:cx,y:cy}=cannonPos();
  let dx = px - cx, dy = py - cy;
  const len = Math.hypot(dx,dy) || 1;
  dx/=len; dy/=len;
  // 下向き過ぎだと自分に当たりやすいので少し上向きに補正
  if(dy>0 && Math.abs(dy)>0.2){ dy *= 0.6; }
  const norm = Math.hypot(dx,dy)||1;
  aimDX=dx/norm; aimDY=dy/norm;
  cannonAngle = Math.atan2(aimDY, aimDX);
}
canvas.addEventListener('pointerdown', e=>{
  if(state!=='playing') return;
  const p=canvasPos(e);
  const {x:cx,y:cy}=cannonPos();
  const dist = Math.hypot(p.x-cx, p.y-cy);
  if(dist <= CFG.aimRadius){
    updateAimFromPoint(p.x,p.y);
    aiming = true;
    capturedPointer = e.pointerId;
    canvas.setPointerCapture?.(capturedPointer);
  }
});
canvas.addEventListener('pointermove', e=>{
  if(!aiming || state!=='playing') return;
  const p=canvasPos(e);
  updateAimFromPoint(p.x,p.y);
});
addEventListener('pointerup', e=>{
  if(capturedPointer!==null){ try{ canvas.releasePointerCapture?.(capturedPointer); }catch(_){} }
  capturedPointer=null;
  aiming=false;
});

/* ======= パーティクル ======= */
function spawnStarParticles(s){
  const n = CFG.particleN;
  for(let i=0;i<n;i++){
    const a = Math.random()*Math.PI*2, sp = rand(80,240);
    particles.push({
      x:s.x, y:s.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp,
      life: rand(280,520),
      type: s.type
    });
  }
}
function spawnBeamHitParticles(x,y,type){
  // ビーム衝突の小さな爆発
  for(let i=0;i<10;i++){
    const a=Math.random()*Math.PI*2, sp=rand(120,260);
    particles.push({x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life:rand(200,380), type:(type==='rainbow'?'rainbow':'normal')});
  }
}

/* ======= 更新 ======= */
function update(dt){
  elapsed += dt;

  // スポーン
  spawnTimer += dt*1000;
  if(spawnTimer>=nextSpawn){
    spawnTimer=0; nextSpawn=pickNextSpawn(); spawnStar();
  }

  // 砲台が照準中：規定間隔でパルスビーム生成
  if(aiming){
    fireTimer += dt;
    while(fireTimer >= CFG.fireInterval){
      fireTimer -= CFG.fireInterval;
      const {x:cx,y:cy}=cannonPos();
      // ビームの先頭を砲口から少し離して生成（重なり軽減）
      const ox = cx + Math.cos(cannonAngle)*20;
      const oy = cy + Math.sin(cannonAngle)*-0 + (-Math.sin(0))*0; // ダミー（可読性用）
      beams.push({
        x: ox, y: cy-12,        // 砲口付近
        dx: aimDX, dy: aimDY,
        len: CFG.beamLen
      });
    }
  }else{
    fireTimer = 0;
  }

  // 星の移動
  for(let i=stars.length-1;i>=0;i--){
    const s = stars[i];
    s.x += s.vx*dt;
    s.y += s.vy*dt;

    if(s.x < s.r+6){ s.x=s.r+6; s.vx=Math.abs(s.vx)*0.85; }
    if(s.x > viewW-(s.r+6)){ s.x=viewW-(s.r+6); s.vx=-Math.abs(s.vx)*0.85; }

    if(s.y - s.r > viewH){
      misses++; updateHUD();
      stars.splice(i,1);
      if(misses>=CFG.maxMiss){ toGameOver(); }
    }
  }

  // ビーム移動＆当たり
  for(let i=beams.length-1;i>=0;i--){
    const b = beams[i];
    // 進行
    b.x += b.dx * CFG.beamSpeed * dt;
    b.y += b.dy * CFG.beamSpeed * dt;

    // 画面外で破棄
    if(b.x < -50 || b.x > viewW+50 || b.y < -50 || b.y > viewH+50){
      beams.splice(i,1); continue;
    }

    // 短い線分の終端
    const ex = b.x + b.dx * b.len;
    const ey = b.y + b.dy * b.len;

    // 星との衝突（当たったらビームは消える）
    let hit = false;
    for(let j=stars.length-1;j>=0;j--){
      const s = stars[j];
      if(segCircleHit(b.x,b.y, ex,ey, s.x,s.y, s.r)){
        const bonus = (s.type==='rainbow') ? CFG.rainbowBonus : 1;
        score += CFG.scorePerStar * bonus;
        updateHUD();
        spawnStarParticles(s);
        spawnBeamHitParticles(s.x, s.y, s.type);
        stars.splice(j,1);
        hit = true;
        break;
      }
    }
    if(hit){ beams.splice(i,1); continue; }
  }

  // パーティクル
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.vx*=0.985; p.vy=(p.vy+600*dt)*0.985;
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    p.life -= dt*1000;
    if(p.life<=0) particles.splice(i,1);
  }
}

/* ======= 判定 ======= */
function segCircleHit(ax,ay,bx,by,cx,cy,r){
  const abx=bx-ax, aby=by-ay;
  const t = clamp(((cx-ax)*abx + (cy-ay)*aby) / (abx*abx+aby*aby||1), 0, 1);
  const px=ax+abx*t, py=ay+aby*t;
  const dx=cx-px, dy=cy-py;
  return (dx*dx+dy*dy) <= r*r;
}

/* ======= 描画 ======= */
function render(){
  ctx.clearRect(0,0,viewW,viewH);
  drawBackdropStars();

  // 星
  for(const s of stars) drawStar(s);

  // 砲台（角度反映）
  drawCannon(cannonAngle);

  // パルスビーム
  for(const b of beams) drawPulseBeam(b);

  // パーティクル
  for(const p of particles) drawParticle(p);
}

function drawBackdropStars(){
  const n = Math.floor(viewW*viewH/22000);
  ctx.fillStyle = 'rgba(255,255,255,.15)';
  for(let i=0;i<n;i++){
    const x = (i*73 % viewW), y = (i*127 % viewH);
    ctx.fillRect(x, y, 1, 1);
  }
}

function drawStar(s){
  ctx.save();
  ctx.translate(s.x, s.y);
  const grad = ctx.createRadialGradient(0,0, s.r*0.2, 0,0, s.r*1.6);
  if(s.type==='rainbow'){
    grad.addColorStop(0, 'rgba(255,255,255,.95)');
    grad.addColorStop(0.5, 'rgba(168,85,247,.35)');
    grad.addColorStop(1, 'rgba(34,211,238,.15)');
  }else{
    grad.addColorStop(0, 'rgba(255,255,255,.9)');
    grad.addColorStop(0.5, 'rgba(252,211,77,.35)');
    grad.addColorStop(1, 'rgba(252,211,77,.12)');
  }
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(0,0, s.r*1.4, 0, Math.PI*2); ctx.fill();
  drawStarShape(0,0, s.r, s.type==='rainbow');
  ctx.restore();
}
function drawStarShape(x,y,r, rainbow){
  ctx.save(); ctx.translate(x,y);
  const spikes=5, outer=r, inner=r*0.5;
  ctx.beginPath();
  for(let i=0;i<spikes*2;i++){
    const ang = (Math.PI/spikes)*i - Math.PI/2;
    const rad = (i%2===0 ? outer : inner);
    ctx.lineTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
  }
  ctx.closePath();
  if(rainbow){
    ctx.fillStyle='#ffffff'; ctx.fill();
    const grad = ctx.createLinearGradient(-outer,-outer,outer,outer);
    grad.addColorStop(0,'#22d3ee'); grad.addColorStop(0.5,'#a78bfa'); grad.addColorStop(1,'#f472b6');
    ctx.lineWidth = Math.max(1.6, r*0.18);
    ctx.strokeStyle = grad; ctx.stroke();
  }else{
    ctx.fillStyle = getVar('--star');
    ctx.strokeStyle = getVar('--starEdge');
    ctx.lineWidth = Math.max(1.4, r*0.16);
    ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

function drawPulseBeam(b){
  // 短いセグメント（末端方向へlen）
  const ex = b.x + b.dx * b.len;
  const ey = b.y + b.dy * b.len;

  // 外側グロー
  const grad = ctx.createLinearGradient(b.x,b.y, ex,ey);
  grad.addColorStop(0, 'rgba(147,197,253,.35)');
  grad.addColorStop(1, 'rgba(96,165,250,.08)');
  ctx.strokeStyle = grad;
  ctx.lineWidth = 10;
  ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(ex,ey); ctx.stroke();

  // コア
  ctx.strokeStyle = getVar('--beam');
  ctx.lineWidth = 6;
  ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(ex,ey); ctx.stroke();
}

function drawCannon(angleRad){
  const cx=viewW/2, cy=viewH-10;
  // 影
  ctx.fillStyle='rgba(255,255,255,.06)';
  ctx.beginPath(); ctx.ellipse(cx, viewH-4, 40, 8, 0, 0, Math.PI*2); ctx.fill();

  // 台座
  ctx.fillStyle='rgba(255,255,255,.15)';
  ctx.fillRect(cx-28, cy-16, 56, 16);

  // 砲身（角度反映）
  ctx.save();
  ctx.translate(cx, cy-16);
  ctx.rotate(angleRad);
  ctx.fillStyle='rgba(147,197,253,.7)';
  ctx.fillRect(-6, -6, 40, 12); // 横長の砲身
  ctx.restore();
}

function drawParticle(p){
  const a = Math.max(0, Math.min(1, p.life/520));
  ctx.fillStyle = (p.type==='rainbow') ? `rgba(167,139,250,${a})` : `rgba(252,211,77,${a})`;
  ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill();
}

function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

/* ======= HUD ======= */
function updateHUD(){
  scoreEl.textContent = String(score);
  missEl.textContent  = String(misses);
}

/* ======= ループ ======= */
function loop(t){
  const dt = Math.min(32, t - lastT)/1000 || 0; lastT=t;
  if(state==='playing'){ update(dt); }
  render();
  requestAnimationFrame(loop);
}

/* ======= 起動 ======= */
function onResize(){}
fullReset();
requestAnimationFrame(loop);
</script>
</body>
</html>