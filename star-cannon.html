<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>スターキャノン</title>
<style>
  :root{
    --bg:#070b1a; --panel:#0b1220; --text:#e5e7eb; --muted:#9ca3af;
    --skyTop:#0b1023; --skyBottom:#0b1633;
    --star:#fcd34d; --starEdge:#7c5c0a;
    --beam:#60a5fa; --beamCore:#93c5fd;
    --border:rgba(255,255,255,.08);
  }
  *{box-sizing:border-box}
  html,body{
    height:100%; margin:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP","Hiragino Sans","Yu Gothic UI",sans-serif;
    overflow:hidden; touch-action:none;
  }
  header{
    height:44px; padding:8px 12px; border-bottom:1px solid var(--border); background:var(--panel);
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  h1{margin:0; font-size:16px; white-space:nowrap}
  .score{
    font-weight:800; background:rgba(255,255,255,.06); border:1px solid var(--border);
    padding:4px 10px; border-radius:999px; font-variant-numeric:tabular-nums; font-size:13px;
  }
  main{
    height:calc(100dvh - 44px); max-width:980px; margin:0 auto; padding:8px; display:flex; flex-direction:column;
  }
  .stage{
    position:relative; flex:1; border:1px solid var(--border); border-radius:12px; overflow:hidden;
    background:linear-gradient(180deg,var(--skyTop),var(--skyBottom));
  }
  canvas{width:100%; height:100%; display:block}

  .overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .overlay .plain{
    pointer-events:auto; background:transparent; border:1px solid #fff; color:#fff;
    padding:10px 18px; font-weight:800; border-radius:8px; cursor:pointer; touch-action:manipulation;
  }
  .overlay.hidden{ display:none; }

  .hud{
    position:absolute; left:8px; top:8px; color:var(--muted); font-size:12px; background:rgba(0,0,0,.25);
    padding:3px 6px; border-radius:8px; border:1px solid var(--border)
  }
</style>
</head>
<body>
  <header>
    <h1>スターキャノン</h1>
    <div class="score">SCORE: <span id="score">0</span></div>
  </header>

  <main>
    <section class="stage" id="stage">
      <canvas id="game" width="720" height="1080" aria-label="ゲーム画面"></canvas>

      <div id="hud" class="hud">MISS: <span id="miss">0</span>/3</div>

      <div id="overlay" class="overlay" role="dialog" aria-modal="true">
        <button id="btnStart" class="plain" type="button" aria-label="開始">START</button>
      </div>
    </section>
  </main>

<script>
/* ======= 状態 ======= */
let state='idle', starting=false, lastT=0;

const stage   = document.getElementById('stage');
const canvas  = document.getElementById('game');
const ctx     = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const missEl  = document.getElementById('miss');
const overlay = document.getElementById('overlay');
const startBtn= document.getElementById('btnStart');

let viewW=720, viewH=1080, dpr=1;
function fitCanvas(){
  const rect = stage.getBoundingClientRect();
  dpr = Math.min(window.devicePixelRatio||1, 2);
  canvas.width  = Math.max(360, Math.floor(rect.width  * dpr));
  canvas.height = Math.max(480, Math.floor(rect.height * dpr));
  canvas.style.width  = rect.width + 'px';
  canvas.style.height = rect.height + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  viewW = rect.width; viewH = rect.height;
  onResize();
}
addEventListener('resize', fitCanvas, {passive:true});

/* ======= スタート/リスタート ======= */
function toPlaying(){
  state='playing';
  overlay.classList.add('hidden');
  score=0; misses=0; elapsed=0; updateHUD();
  stars.length=particles.length=0;
  spawnTimer=0; nextSpawn=pickNextSpawn();
  aiming=false;
}
function toGameOver(){
  state='gameover';
  overlay.classList.remove('hidden');
  startBtn.textContent='RESTART';
  aiming=false;
}
function fullReset(){
  state='idle'; starting=false; lastT=0;
  fitCanvas();
  initGameObjects();
  startBtn.textContent='START';
  overlay.classList.remove('hidden');
  updateHUD();
}
function safeStart(){
  if(starting || state==='playing') return;
  starting = true;
  fullReset(); toPlaying();
  setTimeout(()=>{ starting=false; }, 120);
}
function onBtn(e){ e?.preventDefault?.(); e?.stopPropagation?.(); safeStart(); }
startBtn.addEventListener('click', onBtn);
startBtn.addEventListener('pointerdown', onBtn);
startBtn.addEventListener('touchstart', onBtn, {passive:false});
canvas.addEventListener('pointerdown', e=>{ if(state!=='playing') onBtn(e); });

/* ======= 設定 ======= */
const CFG = {
  starRMin: 10, starRMax: 16,
  rainbowChance: 0.07,
  rainbowBonus: 5,

  vyBaseMin: 80, vyBaseMax: 140,
  vyMaxBoost: 2.2,
  driftMax: 40,

  spawnMin: 380, spawnMax: 1000,
  spawnMinLimit: 240,

  maxMiss: 3,
  scorePerStar: 10,

  particleN: 16,

  // 破線ビーム
  beamDash:[10,8],
  beamWidth:6,
  beamGlow:1.8,

  // 砲台照準を受け付ける半径（砲台中心からの距離）
  aimRadius: 110
};

/* なめらか加速 */
function smooth01(x, k=35){ return 1 - Math.exp(-x / k); }
function speedScaleByTime(sec){
  const t = smooth01(sec, 60);
  return 1 + CFG.vyMaxBoost * t;
}
function spawnMillisByScore(score){
  const t = smooth01(score, 50);
  const min = Math.max(CFG.spawnMinLimit, CFG.spawnMin - 240*t);
  const max = CFG.spawnMax - 260*t*0.7;
  return {min, max:Math.max(min+80, max)};
}

/* ======= 変数 ======= */
let score=0, misses=0, elapsed=0;
let stars=[], particles=[];
let spawnTimer=0, nextSpawn=600;

/* 連続ビーム：砲台近傍で方向だけ指定 */
let aiming=false;
let aimDX=0, aimDY=-1;   // 正規化された方向ベクトル（上向き初期値）
let capturedPointer=null;

/* ======= 初期化 ======= */
function initGameObjects(){
  score=0; misses=0; elapsed=0;
  stars.length=particles.length=0;
  spawnTimer=0; nextSpawn=pickNextSpawn();
  aiming=false; aimDX=0; aimDY=-1; capturedPointer=null;
}
function onResize(){}

/* ======= 便利 ======= */
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function pickNextSpawn(){
  const {min,max} = spawnMillisByScore(score);
  return min + Math.random()*(max-min);
}

/* ======= 星生成 ======= */
function spawnStar(){
  const isRainbow = Math.random() < CFG.rainbowChance;
  const r  = isRainbow ? rand(CFG.starRMin+2, CFG.starRMax+3) : rand(CFG.starRMin, CFG.starRMax);
  const x  = rand(r+8, viewW - (r+8));
  const vy = rand(CFG.vyBaseMin, CFG.vyBaseMax) * speedScaleByTime(elapsed);
  const vx = rand(-CFG.driftMax, CFG.driftMax);
  stars.push({x, y:-r-10, r, vx, vy, type: isRainbow?'rainbow':'normal'});
}

/* ======= 入力：砲台周辺だけで方向を指定 ======= */
function canvasPos(e){
  const rect = canvas.getBoundingClientRect();
  return {x:(e.clientX-rect.left), y:(e.clientY-rect.top)};
}
function cannonPos(){
  return {x:viewW/2, y:viewH-24};
}
function updateAimFromPoint(px,py){
  const {x:cx,y:cy}=cannonPos();
  let dx = px - cx, dy = py - cy;
  const len = Math.hypot(dx,dy) || 1;
  dx/=len; dy/=len;
  // 下方向（dy>0）も許容するが、僅かに上向きに補正して自爆しにくく
  if(dy>0 && Math.abs(dy)>0.2){ dy *= 0.6; } 
  const norm = Math.hypot(dx,dy)||1;
  aimDX=dx/norm; aimDY=dy/norm;
}
canvas.addEventListener('pointerdown', e=>{
  if(state!=='playing') return;
  const p=canvasPos(e);
  const {x:cx,y:cy}=cannonPos();
  const dist = Math.hypot(p.x-cx, p.y-cy);
  if(dist <= CFG.aimRadius){
    updateAimFromPoint(p.x,p.y);
    aiming = true;
    capturedPointer = e.pointerId;
    canvas.setPointerCapture?.(capturedPointer);
  }
});
canvas.addEventListener('pointermove', e=>{
  if(!aiming || state!=='playing') return;
  const p=canvasPos(e);
  updateAimFromPoint(p.x,p.y);
});
addEventListener('pointerup', e=>{
  if(capturedPointer!==null){
    try{ canvas.releasePointerCapture?.(capturedPointer); }catch(_){}
    capturedPointer=null;
  }
  aiming=false;
});

/* ======= パーティクル ======= */
function spawnStarParticles(s){
  const n = CFG.particleN;
  for(let i=0;i<n;i++){
    const a = Math.random()*Math.PI*2, sp = rand(80,240);
    particles.push({
      x:s.x, y:s.y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp,
      life: rand(280,520),
      type: s.type
    });
  }
}

/* ======= 更新 ======= */
function update(dt){
  elapsed += dt;

  // スポーン
  spawnTimer += dt*1000;
  if(spawnTimer>=nextSpawn){
    spawnTimer=0; nextSpawn=pickNextSpawn(); spawnStar();
  }

  // 星の移動
  for(let i=stars.length-1;i>=0;i--){
    const s = stars[i];
    s.x += s.vx*dt;
    s.y += s.vy*dt;

    if(s.x < s.r+6){ s.x=s.r+6; s.vx=Math.abs(s.vx)*0.85; }
    if(s.x > viewW-(s.r+6)){ s.x=viewW-(s.r+6); s.vx=-Math.abs(s.vx)*0.85; }

    if(s.y - s.r > viewH){
      misses++; updateHUD();
      stars.splice(i,1);
      if(misses>=CFG.maxMiss){ toGameOver(); }
    }
  }

  // 連続ビーム命中（砲台→方向ベクトルの“半無限線分”として判定）
  if(aiming){
    const {x:cx,y:cy}=cannonPos();
    const L = Math.hypot(viewW,viewH) * 1.6; // 画面対角より少し長い
    const bx = cx + aimDX*L, by = cy + aimDY*L;

    for(let i=stars.length-1;i>=0;i--){
      const s=stars[i];
      if(segCircleHit(cx,cy,bx,by, s.x,s.y, s.r)){
        const bonus = (s.type==='rainbow') ? CFG.rainbowBonus : 1;
        score += CFG.scorePerStar * bonus;
        updateHUD();
        spawnStarParticles(s);
        stars.splice(i,1);
      }
    }
  }

  // パーティクル
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.vx*=0.985; p.vy=(p.vy+600*dt)*0.985;
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    p.life -= dt*1000;
    if(p.life<=0) particles.splice(i,1);
  }

  // 破線の流れ
  dashOffset = (dashOffset + 240*dt) % 1000;
}

/* ======= 判定 ======= */
function segCircleHit(ax,ay,bx,by,cx,cy,r){
  const abx=bx-ax, aby=by-ay;
  const t = clamp(((cx-ax)*abx + (cy-ay)*aby) / (abx*abx+aby*aby||1), 0, 1);
  const px=ax+abx*t, py=ay+aby*t;
  const dx=cx-px, dy=cy-py;
  return (dx*dx+dy*dy) <= r*r;
}

/* ======= 描画 ======= */
let dashOffset=0;
function render(){
  ctx.clearRect(0,0,viewW,viewH);
  drawBackdropStars();

  // 星
  for(const s of stars) drawStar(s);

  // 砲台
  drawCannon();

  // 連続ビーム（破線）— 砲台近傍で照準している間のみ
  if(aiming){
    const {x:cx,y:cy}=cannonPos();
    const L = Math.hypot(viewW,viewH) * 1.6;
    const bx = cx + aimDX*L, by = cy + aimDY*L;
    drawDashedBeam(cx,cy,bx,by);

    // 照準リング（砲台近辺にうっすら）
    ctx.strokeStyle='rgba(255,255,255,.15)';
    ctx.lineWidth=1.5;
    ctx.beginPath(); ctx.arc(cx,cy, CFG.aimRadius, 0, Math.PI*2); ctx.stroke();
  }

  // パーティクル
  for(const p of particles) drawParticle(p);
}

function drawBackdropStars(){
  const n = Math.floor(viewW*viewH/22000);
  ctx.fillStyle = 'rgba(255,255,255,.15)';
  for(let i=0;i<n;i++){
    const x = (i*73 % viewW), y = (i*127 % viewH);
    ctx.fillRect(x, y, 1, 1);
  }
}

function drawStar(s){
  ctx.save();
  ctx.translate(s.x, s.y);
  const grad = ctx.createRadialGradient(0,0, s.r*0.2, 0,0, s.r*1.6);
  if(s.type==='rainbow'){
    grad.addColorStop(0, 'rgba(255,255,255,.95)');
    grad.addColorStop(0.5, 'rgba(168,85,247,.35)');
    grad.addColorStop(1, 'rgba(34,211,238,.15)');
  }else{
    grad.addColorStop(0, 'rgba(255,255,255,.9)');
    grad.addColorStop(0.5, 'rgba(252,211,77,.35)');
    grad.addColorStop(1, 'rgba(252,211,77,.12)');
  }
  ctx.fillStyle = grad;
  ctx.beginPath(); ctx.arc(0,0, s.r*1.4, 0, Math.PI*2); ctx.fill();
  drawStarShape(0,0, s.r, s.type==='rainbow');
  ctx.restore();
}
function drawStarShape(x,y,r, rainbow){
  ctx.save(); ctx.translate(x,y);
  const spikes=5, outer=r, inner=r*0.5;
  ctx.beginPath();
  for(let i=0;i<spikes*2;i++){
    const ang = (Math.PI/spikes)*i - Math.PI/2;
    const rad = (i%2===0 ? outer : inner);
    ctx.lineTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
  }
  ctx.closePath();
  if(rainbow){
    ctx.fillStyle='#ffffff'; ctx.fill();
    const grad = ctx.createLinearGradient(-outer,-outer,outer,outer);
    grad.addColorStop(0,'#22d3ee'); grad.addColorStop(0.5,'#a78bfa'); grad.addColorStop(1,'#f472b6');
    ctx.lineWidth = Math.max(1.6, r*0.18);
    ctx.strokeStyle = grad; ctx.stroke();
  }else{
    ctx.fillStyle = getVar('--star');
    ctx.strokeStyle = getVar('--starEdge');
    ctx.lineWidth = Math.max(1.4, r*0.16);
    ctx.fill(); ctx.stroke();
  }
  ctx.restore();
}

function drawDashedBeam(ax,ay,bx,by){
  // 外側発光
  const grad = ctx.createLinearGradient(ax,ay,bx,by);
  grad.addColorStop(0, 'rgba(147,197,253,.35)');
  grad.addColorStop(1, 'rgba(96,165,250,.08)');
  ctx.save();
  ctx.setLineDash(CFG.beamDash);
  ctx.lineDashOffset = -dashOffset;
  ctx.strokeStyle = grad;
  ctx.lineWidth = CFG.beamWidth * CFG.beamGlow;
  ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
  ctx.restore();

  // コア
  ctx.save();
  ctx.setLineDash(CFG.beamDash);
  ctx.lineDashOffset = -dashOffset;
  ctx.strokeStyle = getVar('--beam');
  ctx.lineWidth = CFG.beamWidth;
  ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
  ctx.restore();
}

function drawCannon(){
  const cx=viewW/2, cy=viewH-10, w=56, h=16;
  ctx.fillStyle='rgba(255,255,255,.06)';
  ctx.beginPath(); ctx.ellipse(cx, viewH-4, 40, 8, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='rgba(255,255,255,.15)';
  ctx.fillRect(cx-w/2, cy-h, w, h);
  ctx.fillStyle='rgba(147,197,253,.6)';
  ctx.fillRect(cx-4, cy-h-16, 8, 16);
}

function drawParticle(p){
  const a = Math.max(0, Math.min(1, p.life/520));
  ctx.fillStyle = (p.type==='rainbow') ? `rgba(167,139,250,${a})` : `rgba(252,211,77,${a})`;
  ctx.beginPath(); ctx.arc(p.x,p.y,2.2,0,Math.PI*2); ctx.fill();
}

function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

/* ======= HUD ======= */
function updateHUD(){
  scoreEl.textContent = String(score);
  missEl.textContent  = String(misses);
}

/* ======= ループ ======= */
function loop(t){
  const dt = Math.min(32, t - lastT)/1000 || 0; lastT=t;
  if(state==='playing'){ update(dt); }
  render();
  requestAnimationFrame(loop);
}

/* ======= 起動 ======= */
function onResize(){}
fullReset();
requestAnimationFrame(loop);
</script>
</body>
</html>