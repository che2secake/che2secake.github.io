<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>スライドパズル</title>
<style>
  :root{
    --bg:#fefefe; --panel:#ffffff; --text:#374151; --muted:#6b7280; --border:#e5e7eb;
    /* パステルカラー（可愛い色） */
    --tile-colors:#fde68a,#fca5a5,#a5b4fc,#6ee7b7,#f9a8d4,#93c5fd,#fdba74,#c4b5fd,#fcd34d,#fda4af,#86efac,#67e8f9,#fbbf24,#f87171,#60a5fa;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans JP","Hiragino Sans","Yu Gothic UI",sans-serif;overflow:hidden}
  header{height:52px;padding:10px 12px;border-bottom:1px solid var(--border);background:var(--panel);display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{margin:0;font-size:16px}
  .hud{display:flex;gap:8px;align-items:center}
  .pill{font-variant-numeric:tabular-nums;background:#f3f4f6;border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:13px}
  .sel{appearance:none;background:#f3f4f6;color:var(--text);border:1px solid var(--border);border-radius:999px;padding:6px 10px}
  .btn{appearance:none;border:1px solid var(--border);background:#f3f4f6;color:var(--text);border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn:active{transform:translateY(1px)}

  main{height:calc(100dvh - 52px);max-width:980px;margin:0 auto;padding:12px;display:flex;flex-direction:column}
  .stage{position:relative;flex:1;border:1px solid var(--border);border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#fefefe,#f9fafb)}
  .boardWrap{height:100%;display:grid;place-items:center;padding:8px}
  /* スマホでも必ず収まる：vmin と vw の両方で制御 */
  .board{--n:4;width:min(90vmin,95vw,520px);aspect-ratio:1/1;display:grid;
         grid-template-columns:repeat(var(--n),1fr);grid-template-rows:repeat(var(--n),1fr);gap:6px}

  .tile{
    display:grid;place-items:center;border-radius:12px;font-weight:800;
    font-size:clamp(18px,6vmin,28px);color:#374151;
    box-shadow:0 4px 8px rgba(0,0,0,.15);
    transition:filter .2s,transform .2s;
    background: var(--tileColor,#f3f4f6); /* ← 各タイルの色をCSS変数で受け取る */
  }
  .tile.empty{background:transparent;border:2px dashed #d1d5db;box-shadow:none}

  /* ★ 正しい位置にあるタイル（細めの黒枠＋立体感） */
  .tile.fixed{
    outline:1.5px solid rgba(0,0,0,.9);             /* 太枠を“半分”に */
    /* 上が明るく下が少し暗い → 立体感 */
    background:
      linear-gradient(180deg, rgba(255,255,255,0.85), rgba(0,0,0,0.08)),
      var(--tileColor,#f3f4f6);
    box-shadow:
      inset 0 2px 3px rgba(255,255,255,0.85),  /* 上のハイライト */
      inset 0 -2px 3px rgba(0,0,0,0.25),       /* 下のシャドウ */
      0 4px 10px rgba(0,0,0,.18);              /* 外側影で持ち上がり */
  }
  /* ★ ハマった瞬間だけ「ポン」演出 */
  .tile.justFixed{animation:popFixed .35s ease-out}
  @keyframes popFixed{
    0%{transform:scale(.94);filter:brightness(1.12)}
    60%{transform:scale(1.06);filter:brightness(1.23)}
    100%{transform:scale(1.00);filter:brightness(1.00)}
  }

  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .overlay .plain{pointer-events:auto;background:#fff;border:1px solid #ccc;color:var(--text);
                  padding:10px 18px;font-weight:800;border-radius:8px;cursor:pointer;touch-action:manipulation}
  .overlay.hidden{display:none}
  .msg{position:absolute;bottom:12px;left:12px;background:#ffffffcc;border:1px solid var(--border);
       border-radius:10px;padding:6px 10px;font-size:12px;color:var(--muted)}

  /* === 祝福演出（点滅＋紙吹雪） === */
  .flashLayer{position:absolute;inset:0;pointer-events:none;mix-blend-mode:screen;opacity:0;
    background:radial-gradient(120% 80% at 50% 50%,rgba(255,255,255,.85),transparent 60%);
    animation:flashStrobe .12s linear infinite}
  .flashActive{opacity:.85}
  @keyframes flashStrobe{
    0%{filter:brightness(1) saturate(1.2)}
    50%{filter:brightness(2.2) saturate(1.6)}
    100%{filter:brightness(1) saturate(1.2)}
  }
  .glowAll .tile:not(.empty){
    box-shadow:
      0 0 0 2px rgba(255,255,255,.7),
      0 0 16px rgba(255,99,132,.35),
      0 0 24px rgba(54,162,235,.25),
      0 0 36px rgba(255,206,86,.2);
    filter:saturate(1.2) brightness(1.05);
  }
  #confetti{position:absolute;inset:0;pointer-events:none}
</style>
</head>
<body>
  <header>
    <h1>スライドパズル</h1>
    <div class="hud">
      <span class="pill">手数: <span id="moves">0</span></span>
      <select id="sizeSel" class="sel" title="サイズ">
        <option value="3">3 × 3</option>
        <option value="4" selected>4 × 4</option>
      </select>
      <button id="btnShuffle" class="btn">シャッフル</button>
    </div>
  </header>

  <main>
    <section class="stage" id="stage">
      <div class="boardWrap">
        <div id="board" class="board" aria-label="パズル盤面"></div>
      </div>

      <!-- 祝福演出 -->
      <canvas id="confetti" width="10" height="10" aria-hidden="true"></canvas>
      <div id="flash" class="flashLayer" aria-hidden="true"></div>

      <div id="overlay" class="overlay" role="dialog" aria-modal="true">
        <button id="btnStart" class="plain" type="button" aria-label="開始">START</button>
      </div>

      <div id="msg" class="msg">空白の隣のタイルをタップでスライド。START/RESTARTでやり直し。</div>
    </section>
  </main>

<script>
/* ========== 状態・要素 ========== */
let state='idle', starting=false;
const stageEl=document.getElementById('stage');
const boardEl=document.getElementById('board');
const movesEl=document.getElementById('moves');
const sizeSel=document.getElementById('sizeSel');
const btnShuffle=document.getElementById('btnShuffle');
const overlay=document.getElementById('overlay');
const startBtn=document.getElementById('btnStart');
const flashEl=document.getElementById('flash');
const confettiCanvas=document.getElementById('confetti');
const cctx=confettiCanvas.getContext('2d');

let N=4;                 // 3 or 4
let tiles=[];            // 1..N*N-1, 0=空白
let moves=0;
let lastFixed = new Set(); // 前回レンダで固定だったタイル番号
const pastelColors=getComputedStyle(document.documentElement).getPropertyValue('--tile-colors').split(',');

/* ========== スタート＆リセット ========== */
function toPlaying(){
  overlay.classList.add('hidden');
  state='playing';
  stopCelebration();
  resetBoard(N);
}
function fullReset(){
  starting=false;
  moves=0; movesEl.textContent='0';
  lastFixed=new Set();
  stopCelebration();
  resetBoard(N);
  overlay.classList.remove('hidden');
}
function safeStart(){
  if(starting) return;
  starting=true;
  toPlaying();
  setTimeout(()=>{starting=false;},120);
}
const onBtn=e=>{e?.preventDefault?.(); e?.stopPropagation?.(); safeStart();};
startBtn.addEventListener('click',onBtn);
startBtn.addEventListener('pointerdown',onBtn);
startBtn.addEventListener('touchstart',onBtn,{passive:false});
btnShuffle.addEventListener('click',()=>{
  if(state!=='playing') safeStart();
  shuffleSolvable(); render(); moves=0; movesEl.textContent='0';
});
sizeSel.addEventListener('change',()=>{
  N=parseInt(sizeSel.value,10);
  boardEl.style.setProperty('--n', N);
  safeStart();
  shuffleSolvable(); render(); moves=0; movesEl.textContent='0';
});

/* ========== 盤面 ========== */
function resetBoard(n){
  tiles=[...Array(n*n-1).keys()].map(x=>x+1); tiles.push(0);
  boardEl.style.setProperty('--n', n);
  render();
}

function render(){
  boardEl.innerHTML='';
  const nowFixed = new Set(); // 今回固定だったタイル

  tiles.forEach((v,idx)=>{
    const d=document.createElement('div');

    if(v===0){
      d.className='tile empty';
    }else{
      d.className='tile';
      d.textContent=v;

      // 各タイルのベース色をCSS変数で渡す
      const baseColor = pastelColors[(v-1)%pastelColors.length];
      d.style.setProperty('--tileColor', baseColor);

      // 正しい位置（= 番号-1 と同じ idx）
      const isFixed = (v-1===idx);
      if(isFixed){
        d.classList.add('fixed');  // 細枠＋立体感
        nowFixed.add(v);
        if(!lastFixed.has(v)){     // 新たにハマった瞬間だけ演出
          d.classList.add('justFixed');
          setTimeout(()=>d.classList.remove('justFixed'), 400);
        }
      }

      d.addEventListener('click',()=>tryMove(idx), {passive:true});
    }
    boardEl.appendChild(d);
  });

  lastFixed=nowFixed;
}

function tryMove(idx){
  if(state!=='playing') return;
  const emptyIdx=tiles.indexOf(0);
  const r=Math.floor(idx/N), c=idx%N;
  const er=Math.floor(emptyIdx/N), ec=emptyIdx%N;
  const isAdj=(r===er && Math.abs(c-ec)===1) || (c===ec && Math.abs(r-er)===1);
  if(!isAdj) return;

  swap(idx, emptyIdx);
  moves++; movesEl.textContent=String(moves);
  render();
  if(isSolved()) celebrate();
}
function swap(a,b){ [tiles[a],tiles[b]]=[tiles[b],tiles[a]]; }

function shuffleSolvable(){
  // 完成形から合法手をランダム適用（常に解ける）
  const steps=200+Math.floor(Math.random()*200);
  for(let i=0;i<steps;i++){
    const empty=tiles.indexOf(0);
    const r=Math.floor(empty/N), c=empty%N;
    const cand=[];
    if(r>0) cand.push(empty-N);
    if(r<N-1) cand.push(empty+N);
    if(c>0) cand.push(empty-1);
    if(c<N-1) cand.push(empty+1);
    const pick=cand[Math.floor(Math.random()*cand.length)];
    swap(empty,pick);
  }
}

function isSolved(){
  for(let i=0;i<tiles.length-1;i++){
    if(tiles[i]!==i+1) return false;
  }
  return tiles[tiles.length-1]===0;
}

/* ========== 祝福演出（点滅＋紙吹雪） ========== */
let confettiParticles=[], confettiTimer=null, confettiRunning=false;

function celebrate(){
  stageEl.classList.add('glowAll');      // タイルがふわっと光る
  flashEl.classList.add('flashActive');  // 盤面ストロボ
  startConfetti(3000);                   // 紙吹雪 3秒
}
function stopCelebration(){
  stageEl.classList.remove('glowAll');
  flashEl.classList.remove('flashActive');
  confettiParticles.length=0; confettiRunning=false;
  if(confettiTimer){ clearTimeout(confettiTimer); confettiTimer=null; }
  resizeConfetti();
  cctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
}

/* 紙吹雪 */
function resizeConfetti(){
  const rect=stageEl.getBoundingClientRect();
  const dpr=Math.min(window.devicePixelRatio||1,2);
  confettiCanvas.width=Math.floor(rect.width*dpr);
  confettiCanvas.height=Math.floor(rect.height*dpr);
  confettiCanvas.style.width=rect.width+'px';
  confettiCanvas.style.height=rect.height+'px';
  cctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resizeConfetti, {passive:true});
resizeConfetti();

function rand(a,b){ return a+Math.random()*(b-a); }
function pickConfettiColor(){
  const cs=['#f472b6','#60a5fa','#34d399','#fbbf24','#a78bfa','#f87171'];
  return cs[Math.floor(Math.random()*cs.length)];
}
function spawnConfettiBurst(n=120){
  const rect=stageEl.getBoundingClientRect();
  for(let i=0;i<n;i++){
    confettiParticles.push({
      x:rand(0,rect.width), y:rand(-20,20),
      vx:rand(-120,120), vy:rand(80,220),
      rot:rand(0,Math.PI*2), vr:rand(-6,6),
      w:rand(6,12), h:rand(10,20),
      life:rand(1200,2200), col:pickConfettiColor()
    });
  }
}
function startConfetti(ms=3000){
  if(confettiRunning) return;
  confettiRunning=true; resizeConfetti();
  confettiParticles.length=0;
  spawnConfettiBurst(140);
  const bursts=Math.max(1,Math.floor(ms/600)-1);
  for(let i=1;i<=bursts;i++){
    setTimeout(()=>confettiRunning && spawnConfettiBurst(80), i*450);
  }
  confettiTimer=setTimeout(()=>{confettiRunning=false; stopCelebration();}, ms);
  requestAnimationFrame(confettiLoop);
}
let lastT=0;
function confettiLoop(t){
  if(!confettiRunning) return;
  const dt=Math.min(32,t-lastT)/1000||0; lastT=t;
  // 物理
  for(let i=confettiParticles.length-1;i>=0;i--){
    const p=confettiParticles[i];
    p.vy+=500*dt; p.vx*=0.995;
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.rot+=p.vr*dt; p.life-=dt*1000;
    if(p.y>confettiCanvas.height || p.life<=0) confettiParticles.splice(i,1);
  }
  // 描画
  cctx.clearRect(0,0,confettiCanvas.width,confettiCanvas.height);
  for(const p of confettiParticles){
    cctx.save(); cctx.translate(p.x,p.y); cctx.rotate(p.rot);
    cctx.fillStyle=p.col; cctx.fillRect(-p.w/2,-p.h/2,p.w,p.h); cctx.restore();
  }
  requestAnimationFrame(confettiLoop);
}

/* ========== 初期化 ========== */
(function init(){
  resetBoard(N);
  overlay.classList.remove('hidden'); // 初回はSTART表示
})();
</script>
</body>
</html>