<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>ピンポンゲーム</title>
<style>
  :root{
    --bg:#0b1023; --panel:#0f172a; --text:#e5e7eb; --muted:#9ca3af;
    --accent:#22d3ee; --brick:#94a3b8; --ball:#fbbf24;
  }
  *{box-sizing:border-box}
  html,body{height:100%;overflow:hidden}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Hiragino Sans","Noto Sans JP","Yu Gothic UI",sans-serif}
  header{padding:10px 14px;border-bottom:1px solid rgba(255,255,255,.08);background:var(--panel)}
  h1{margin:0;font-size:18px}
  main{height:calc(100vh - 48px);max-width:980px;margin:0 auto;padding:12px;display:flex;flex-direction:column;gap:8px}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .pill{font-size:12px;padding:4px 10px;border-radius:999px;background:#111827;border:1px solid rgba(255,255,255,.12)}
  /* ステージ（キャンバス＋オーバーレイ）。1画面完結・スクロール無し */
  .stage{position:relative;flex:1;border:1px solid rgba(255,255,255,.06);border-radius:12px;overflow:hidden;background:linear-gradient(180deg,#0f172a,#0b1023)}
  canvas{width:100%;height:100%;display:block;touch-action:none}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.28);text-align:center;gap:12px;flex-direction:column}
  .sheet{background:#0b1220;border:1px solid rgba(255,255,255,.16);padding:18px;border-radius:14px;max-width:90vw;box-shadow:0 20px 50px rgba(0,0,0,.55)}
  .btn{appearance:none;border:1px solid rgba(255,255,255,.2);background:#1f2937;color:var(--text);padding:10px 18px;border-radius:12px;cursor:pointer;font-weight:700}
  .btn:hover{background:#2b3446}
  .hidden{display:none}
</style>
</head>
<body>
  <header><h1>ピンポンゲーム</h1></header>

  <main>
    <!-- 上部は情報表示のみ（ボタンは置かない） -->
    <div class="row">
      <div class="row" style="gap:8px">
        <span class="pill">スコア: <b id="score">0</b></span>
        <span class="pill">残ブロック: <b id="left">0</b></span>
        <span class="pill">ボール: <b id="balls">0</b></span>
        <span class="pill">スピード: <b id="spd">1.0x</b></span>
      </div>
    </div>

    <!-- ステージ：1画面完結 -->
    <div class="stage" id="stage">
      <canvas id="game" width="720" height="1080" aria-label="ゲーム画面"></canvas>
      <div id="overlay" class="overlay">
        <div class="sheet">
          <div id="title" style="font-weight:800;font-size:22px;margin-bottom:8px">START</div>
          <div id="sub" style="color:var(--muted);font-size:12px">タップして開始（スマホはドラッグ/スワイプ、PCは← →）</div>
        </div>
        <button id="btnStart" class="btn">START</button>
      </div>
    </div>
  </main>

<script>
/* ====== 設定 ====== */
const CFG = {
  paddleW: 140, paddleH: 16, paddleSpeed: 900,
  ballR: 10, baseBallSpeed: 420, speedCap: 900,
  rows: 6, cols: 9, brickW: 64, brickH: 22, brickGap: 8, topOffset: 90,
  addBallEvery: 7,           // 7個壊すごとにボール追加
  speedUpFactor: 1.12        // 追加発生ごとに速度倍率アップ
};

/* ====== 要素参照 ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const $ = s=>document.querySelector(s);
const overlay = $('#overlay'), titleEl = $('#title'), subEl = $('#sub'), startBtn = $('#btnStart');
const scoreEl = $('#score'), leftEl = $('#left'), ballsEl = $('#balls'), spdEl = $('#spd');

/* ====== 画面を1ビュー内に収める（スクロール無し） ====== */
function fitCanvas(){
  const rect = document.getElementById('stage').getBoundingClientRect();
  // キャンバスの内部解像度を外枠に合わせる（比率は固定しない：常に1画面）
  canvas.width = Math.floor(rect.width);
  canvas.height = Math.floor(rect.height);
}
addEventListener('resize', fitCanvas);

/* ====== 状態 ====== */
let running=false, paused=false, lastT=0;
let score=0, bricks=[], bricksLeft=0, destroyed=0; // destroyed: 破壊総数
let speedMult=1;            // 現在の速度倍率
let paddle;
let balls=[];               // {x,y,vx,vy,r}

/* ====== 初期化 / リセット ====== */
function reset(){
  score=0; destroyed=0; speedMult=1; balls.length=0; bricks.length=0;
  // パドル
  paddle={x:canvas.width/2, y:canvas.height-60, w:CFG.paddleW, h:CFG.paddleH};
  // ボール1個
  addBall(true);
  // ブロック生成
  const totalW = CFG.cols*CFG.brickW + (CFG.cols-1)*CFG.brickGap;
  const startX = (canvas.width-totalW)/2;
  for(let r=0;r<CFG.rows;r++){
    for(let c=0;c<CFG.cols;c++){
      const x = startX + c*(CFG.brickW+CFG.brickGap);
      const y = CFG.topOffset + r*(CFG.brickH+CFG.brickGap);
      bricks.push({x,y,w:CFG.brickW,h:CFG.brickH,alive:true});
    }
  }
  bricksLeft = bricks.length;
  updateHUD();
}

/* ====== ボール追加（初速はランダム斜め上） ====== */
function addBall(center=false){
  const ang = (Math.PI*0.25) + Math.random()*Math.PI*0.5; // 45°〜135°
  const dir = Math.random()<.5?1:-1;
  const speed = CFG.baseBallSpeed*speedMult;
  const x = center ? canvas.width/2 : paddle.x;
  const y = center ? canvas.height-100 : paddle.y - 30;
  balls.push({x, y, vx:Math.cos(ang)*speed*dir, vy:-Math.abs(Math.sin(ang)*speed), r:CFG.ballR});
  updateHUD();
}

function speedUp(){
  speedMult = Math.min(speedMult*CFG.speedUpFactor, CFG.speedCap/CFG.baseBallSpeed);
  // 既存の全ボール速度を倍率に合わせてスケーリング
  for(const b of balls){
    const s = Math.hypot(b.vx, b.vy);
    const ns = CFG.baseBallSpeed*speedMult;
    if(s>0){ const k = ns/s; b.vx*=k; b.vy*=k; }
  }
  updateHUD();
}

/* ====== ユーティリティ ====== */
function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
function updateHUD(){
  scoreEl.textContent = score;
  leftEl.textContent  = bricksLeft;
  ballsEl.textContent = balls.length;
  spdEl.textContent   = (speedMult).toFixed(2)+'x';
}
function setOverlay(show, titleText, subText, showStartBtn=true){
  if(titleText!==undefined) titleEl.textContent = titleText;
  if(subText!==undefined) subEl.textContent = subText;
  startBtn.classList.toggle('hidden', !showStartBtn);
  overlay.classList.toggle('hidden', !show);
}

/* ====== 描画 ====== */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // パドル
  ctx.fillStyle='#22d3ee';
  ctx.fillRect(paddle.x-paddle.w/2, paddle.y-paddle.h/2, paddle.w, paddle.h);
  // ボール
  ctx.fillStyle= '#fbbf24';
  for(const b of balls){ ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }
  // ブロック
  ctx.fillStyle='#94a3b8';
  for(const br of bricks){ if(!br.alive) continue; ctx.fillRect(br.x,br.y,br.w,br.h); }
}

/* ====== 入力 ====== */
let keyL=false,keyR=false;
addEventListener('keydown', e=>{ if(e.key==='ArrowLeft') keyL=true; if(e.key==='ArrowRight') keyR=true; });
addEventListener('keyup', e=>{ if(e.key==='ArrowLeft') keyL=false; if(e.key==='ArrowRight') keyR=false; });

function tickKeys(dt){
  let dir=0; if(keyL)dir-=1; if(keyR)dir+=1;
  paddle.x += CFG.paddleSpeed*dt*dir;
  paddle.x = clamp(paddle.x, paddle.w/2, canvas.width-paddle.w/2);
}

function handlePointer(clientX){
  const rect = canvas.getBoundingClientRect();
  const x = (clientX-rect.left)*(canvas.width/rect.width);
  paddle.x = clamp(x, paddle.w/2, canvas.width-paddle.w/2);
}
canvas.addEventListener('pointerdown', e=>handlePointer(e.clientX));
canvas.addEventListener('pointermove', e=>{ if(e.buttons) handlePointer(e.clientX); });

/* ====== 物理 ====== */
function collideRectCircle(rx,ry,rw,rh, cx,cy,cr){
  const nx = clamp(cx, rx, rx+rw);
  const ny = clamp(cy, ry, ry+rh);
  const dx = cx-nx, dy = cy-ny;
  return dx*dx+dy*dy <= cr*cr;
}
function reflectOnPaddle(ball){
  const hit = (ball.x - paddle.x) / (paddle.w/2); // -1..1
  const s = Math.hypot(ball.vx, ball.vy);
  const angle = (Math.PI*0.15) + (Math.PI*0.7)*(hit+1)/2; // ~27°..153°
  ball.vx = Math.cos(angle)*s;
  ball.vy = -Math.abs(Math.sin(angle)*s);
}

/* ====== ループ ====== */
function loop(t){
  if(!running){ lastT=t; requestAnimationFrame(loop); return; }
  const dt = Math.min(32, t-lastT)/1000; lastT=t;
  if(paused){ requestAnimationFrame(loop); return; }

  tickKeys(dt);

  // ボールごとに更新
  for(let i=balls.length-1;i>=0;i--){
    const b = balls[i];
    b.x += b.vx*dt;
    b.y += b.vy*dt;

    // 壁
    if(b.x-b.r<0){ b.x=b.r; b.vx*=-1; }
    if(b.x+b.r>canvas.width){ b.x=canvas.width-b.r; b.vx*=-1; }
    if(b.y-b.r<0){ b.y=b.r; b.vy*=-1; }

    // パドル
    if(b.vy>0 && collideRectCircle(paddle.x-paddle.w/2, paddle.y-paddle.h/2, paddle.w, paddle.h, b.x, b.y, b.r)){
      reflectOnPaddle(b);
    }

    // ブロック衝突（簡易）
    for(const br of bricks){
      if(!br.alive) continue;
      if(b.x+b.r < br.x || b.x-b.r > br.x+br.w || b.y+b.r < br.y || b.y-b.r > br.y+br.h) continue;
      // 進入方向の判定
      const prevX = b.x - b.vx*dt;
      const prevY = b.y - b.vy*dt;
      let hitX=false, hitY=false;
      if(prevX+b.r <= br.x || prevX-b.r >= br.x+br.w) hitX=true;
      if(prevY+b.r <= br.y || prevY-b.r >= br.y+br.h) hitY=true;
      if(hitX) b.vx*=-1;
      if(hitY || (!hitX && !hitY)) b.vy*=-1;

      br.alive=false; bricksLeft--; destroyed++; score+=10;
      // 7個ごとにボール追加＆加速
      if(destroyed>0 && destroyed % CFG.addBallEvery === 0){
        addBall(false);
        speedUp();
      }
      updateHUD();
      break;
    }

    // 落下 → ボール消滅
    if(b.y-b.r > canvas.height){
      balls.splice(i,1);
      updateHUD();
    }
  }

  // 終了判定
  if(balls.length===0){
    end(false); // GAME OVER
    return;
  }
  if(bricksLeft===0){
